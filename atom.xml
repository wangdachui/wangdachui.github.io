<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技能树整理</title>
  
  <subtitle>奇迹源于钟爱！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangdachui.github.io/"/>
  <updated>2018-07-24T08:29:57.084Z</updated>
  <id>https://wangdachui.github.io/</id>
  
  <author>
    <name>王涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CoreBluetooth的后台工作模式</title>
    <link href="https://wangdachui.github.io/2018/07/24/CoreBluetooth/"/>
    <id>https://wangdachui.github.io/2018/07/24/CoreBluetooth/</id>
    <published>2018-07-24T08:05:04.000Z</published>
    <updated>2018-07-24T08:29:57.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>默认情况下当App处于后台/挂起状态之后，所有BLE相关的操作将不可用，也接收不到任何BLE事件通知，直到该App恢复到前台运行为止。</p><p>针对App需要在后台/挂起的状态下执行BLE相关任务的场合，CoreBluetooth提供了以下2种方案:<br>利用Peripheral连接选项触发系统通知</p><p>该方案为处于后台/挂起状态的App提供了一个切换到前台来处理BLE事件的窗口，但需要用户授权。当接收到来自Peripheral的事件后，CoreBluetooth会以系统通知来的方式询问用户是否需要切换到处于后台的App来处理该事件。如果用户不同意，App仍将处于后台挂起状态，无法处理来自Peripheral设备的事件。该方案仅适用于Central角色，不要求App具备任何后台运行权限。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在调用CBCentralManager的connectPeripheral:options:函数与Peripheral设备建立连接的时候，以Key-Value形式传入以下参数到options中： </p><pre><code>CBConnectPeripheralOptionNotifyOnConnectionKey - Bool值，Yes为启用，默认为No。启用后当App处于挂起状态时，iOS系统将在每次与Peripheral设备【建立】连接后触发系统通知。CBConnectPeripheralOptionNotifyOnDisconnectionKey - Bool值，YES为启用，默认为No。启用后当App处于挂起状态时，iOS系统将在每次与Peripheral设备【断开】连接后触发系统通知。CBConnectPeripheralOptionNotifyOnNotificationKey - Bool值，Yes为启用，默认为No。启用后当App处于挂起状态时，iOS系统将为所有来自Peripheral的事件触发系统通知。</code></pre><h3 id="系统限制"><a href="#系统限制" class="headerlink" title="系统限制"></a>系统限制</h3><p>如果当前系统内有多个App都以相同的选项连接了相同的Peripheral设备，在用户收到系统通知并同意之后，只有最后一个处于前台运行的App将会被切换到前台运行。</p><h2 id="利用CoreBluetooth后台运行模式"><a href="#利用CoreBluetooth后台运行模式" class="headerlink" title="利用CoreBluetooth后台运行模式"></a>利用CoreBluetooth后台运行模式</h2><p>在CoreBluetooth框架中Central和Peripheral角色的App均可以通过申请对应的后台运行模式，从而能够在后台运行BLE相关的任务。</p><h3 id="Central角色"><a href="#Central角色" class="headerlink" title="Central角色"></a>Central角色</h3><p>所需申请的后台运行模式:</p><ul><li>bluetooth-central (Uses Bluetooth LE accessories)</li></ul><p>当App处于后台运行时可以执行下列BLE相关的任务:</p><ul><li>发现Peripheral设备</li><li>管理Peripheral设备连接</li><li>读写和订阅Peripheral数据</li><li>发送Notification或者Indication到Peripheral</li><li>处理CBCentralManagerDelegate上的事件</li><li>处理CBPeripheralDelegate上的事件</li></ul><p>当App处于挂起状态后系统会唤醒App来处理CBCentralManagerDelegate或者CBPeripheralDelegate上的事件，如果此时App进程已经被系统终止，CoreBluetooth会重启App。</p><p>当App处于后台运行时Peripheral扫描操作会有如下限制:</p><ul><li>代码中设置的扫描选项CBCentralManagerScanOptionAllowDuplicatesKey的值将会被忽略，强制为NO。</li><li>同时有多个App在后台模式扫描Peripheral的场合，对Peripheral广播的扫描间隔会增加，导致发现Peripheral设备的时间增加。</li></ul><h3 id="Peripheral角色"><a href="#Peripheral角色" class="headerlink" title="Peripheral角色"></a>Peripheral角色</h3><p>所需申请的后台运行模式:</p><ul><li>bluetooth-peripheral (Acts as a Bluetooth LE accessory)</li></ul><p>当App处于后台运行可以执行下列BLE相关的任务:</p><ul><li>发送Peripheral广告</li><li>处理来自Central的数据读写和订阅请求</li></ul><p>当App处于挂起状态后系统会唤醒App来处理数据读写和订阅请求，如果此时App进程已经被系统终止，CoreBluetooth会在后台重启App。</p><p>当App处于后台运行时对Peripheral广告会有如下限制:</p><ul><li>CBAdvertisementDataLocalNameKey将会被忽略，Peripheral的本地名称将为空。</li><li>CBAdvertisementDataServiceUUIDsKey中的所有服务UUID将会被放到overflow区域，此时Central在搜索服务时必须指定服务UUID才能发现对应的服务</li><li>同时有多个App在后台模式扫发送Peripheral广告的场合，每个广告之间的间隔时间会增加，导致Peripheral被发现的时间增加。</li></ul><h3 id="CoreBluetooth的状态保存与恢复"><a href="#CoreBluetooth的状态保存与恢复" class="headerlink" title="CoreBluetooth的状态保存与恢复"></a>CoreBluetooth的状态保存与恢复</h3><p>退至后台的App不能保证一直处于挂起状态，在系统资源紧张的时候App进程会被终止掉以释放内存。<br>虽然CoreBluetooth会重新启动App进程，但为接下来能正确执行BLE任务，以下数据需要正确恢复到进程终止前的状态:</p><p> <strong>CBCentralManager</strong></p><ul><li>正在扫描的服务以及对应的扫描选项</li><li>正在连接或者已经连接的Peripheral设备</li><li>订阅了的characteristics</li></ul><p><strong>CBPeripheralManager</strong></p><ul><li>正在广告的数据</li><li>发布了的服务和characteristics</li><li>订阅了characteristics的Central设备</li></ul><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>CoreBluetooth已经提供了CBCenteralManager和CBPeripheralManager状态保存与恢复的API，需要实现以下步骤方可正常使用:</p><ol><li><p>启用实例状态恢复 (必要步骤)</p><p> 在调用CBCentralManager/CBPeripheralManager initWithDelegate: queue: options:函数初始化实例时，以Key-Value形式将下列参数传入options中: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBCentralManagerOptionRestoreIdentifierKey(CBCentralManager) </span><br><span class="line">CBPeripheralManagerOptionRestoreIdentifierKey(CBPeripheralManager)</span><br></pre></td></tr></table></figure></li></ol><pre><code>参数值为NSString类型，作为保存和恢复状态时唯一识别实例的ID。如果有多个实例，应该为为每个实例分配不同的ID。</code></pre><ol start="2"><li><p>重新创建实例 (必要步骤)</p><p> 在App重启时在通过下列Key值可以从UIApplicationDelegate application:didFinishLaunchingWithOptions:事件处理函数的options参数中能够获取到需要恢复的实例ID列表。 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIApplicationLaunchOptionsBluetoothCentralsKey(CBCentralManager)</span><br><span class="line">UIApplicationLaunchOptionsBluetoothPeripheralsKey(CBPeripheralManager)</span><br></pre></td></tr></table></figure><p> 如果存在多个启用了状态恢复的CBCentralManager/CBPeripheralManager实例，CoreBluetooth只会将需要执行后台BLE任务的实例ID放入次列表中。</p><p> 在初始化新建CBCentralManager/CBPeripheralManager实例的时候将列表中对应的ID作为options参数传入。</p></li><li><p>恢复实例状态 (必要步骤)</p><p> 在CBCenteralManagerDelegate centralManager:willRestoreState函数中，可以通过下列的KEY从state参数中获取需要恢复的的CBCentralManager状态数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CBCentralManagerRestoredStatePeripheralsKey - 获取CBPeripheral列表，其中包含了App进程终止时连接上或者处于连接中的Peripheral设备</span><br><span class="line">CBCentralManagerRestoredStateScanServicesKey - 获取CBUUID列表，其中包含了App进程终止时正在扫描的服务UUIDCB</span><br><span class="line">CentralManagerRestoredStateScanOptionsKey - 获取NSDictionary实例，其中包含了App进程终止时正在使用的Peripheral扫描选项</span><br></pre></td></tr></table></figure></li></ol><pre><code>在CBPeripheralManagerDelegate peripheralManager:willRestoreState:函数中，可以通过下列的KEY从state参数中获取需要恢复的CBPeripheralManager状态数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBPeripheralManagerRestoredStateServicesKey - 获取CBMutableService列表，其中包含了App进程终止时已经发布的服务</span><br><span class="line">CBPeripheralManagerRestoredStateAdvertisementDataKey - 获取NSDictionary实例，其中包含了App进程终止时正在发送的Peripheral广告</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>同步任务状态 (可选步骤)<br> 当App进程被终止的时候，可能存在尚未结束的BLE任务，例如读取Peripheral的数据或者扫描Peripheral设备。</p><p> 上述的BLE任务在被CoreBluetooth执行完后会更新到恢复数据中，在下列事件处理函数中能够从恢复数据获取最新的状态:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBCentralManagerDelegate centralManagerDidUpdateState:</span><br><span class="line">CBPeripheralManagerDelegate peripheralManagerDidUpdateState:</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用iOS后台模式的原则"><a href="#使用iOS后台模式的原则" class="headerlink" title="使用iOS后台模式的原则"></a>使用iOS后台模式的原则</h3><ul><li>避免过于频繁的执行后台任务，从而减小对电池续航时间的影响。</li><li>当App在后台被唤醒后应该尽快（10s内）完成处理后返回，避免执行与本次该唤醒无关的任务，从而能让App尽快回到挂起状态。</li><li>单次执行时间过长的后台任务存在被系统降缓执行甚至直接终止进程的风险。</li><li>对于需要长期在后台模式工作的App，需要充分考虑App进程被系统终止后重启的场景，做好任务状态的保存和恢复，并尽量优化后台启动流程，较少不必要的资源开销。</li><li>受iOS系统限制，所有的后台模式都无法唤醒被用户强制关闭的App（在多任务管理界面划掉）。</li></ul><p><strong>官方资料</strong></p><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html" target="_blank" rel="noopener">Core Bluetooth Programming Guide</a></p><p><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html" target="_blank" rel="noopener">Background Execution</a></p><p><a href="https://developer.apple.com/documentation/corebluetooth" target="_blank" rel="noopener">Core Bluetooth API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;默认情况下当App处于后台/挂起状态之后，所有BLE相关的操作将不可用，也接收不到任何BLE事件通知，直到该App恢复到前台运行为止。&lt;/p
      
    
    </summary>
    
    
      <category term="Bluetooth 蓝牙" scheme="https://wangdachui.github.io/tags/Bluetooth-%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>组件化开发调研</title>
    <link href="https://wangdachui.github.io/2018/07/23/sub-module/"/>
    <id>https://wangdachui.github.io/2018/07/23/sub-module/</id>
    <published>2018-07-23T13:08:56.000Z</published>
    <updated>2018-07-24T08:04:01.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件化开发是一种软件架构思想，其目的是提高软件可维护性、代码复用性，有以下几个特点：</p><ol><li><p>组件独立于项目，与项目之间是热插拔的关系，类似linux系统中的服务，启动了就可使用，没启动就不能使用。例如A项目使用a、b、c三个组件，B项目使用b、c、d三个组件。</p></li><li><p>组件之间互相独立，即使a组件要依赖于b组件，a组件也不会直接引入b组件。而是通过协议调用、消息转发等方式解耦</p></li><li><p>组件内部保持职责单一，一个组件只做与它业务相关的事，与之无关事情代理给其他组件做。</p></li></ol><h2 id="组件化的目标："><a href="#组件化的目标：" class="headerlink" title="组件化的目标："></a>组件化的目标：</h2><ol><li><p>多APP共用一套组件，每个组件单独维护，组件的更新维护不影响业务层开发。</p></li><li><p>不同APP以配置的方式接入自己所需要的组件。</p></li><li><p>新组件开发后能快速铺向所有业务。</p></li><li><p>未来的新APP，共用一套底层框架，能保证产品的稳定性和快速迭代。</p></li></ol><h2 id="Part1-目前代码结构中的问题"><a href="#Part1-目前代码结构中的问题" class="headerlink" title="Part1 目前代码结构中的问题"></a>Part1 目前代码结构中的问题</h2><p>1）代码复用性低，每个业务都维护自己的代码</p><p>2）业务内各个模块耦合严重。模块内职责混乱，如FXCommonTool，目前FXCommonTool里面的功能有：网络请求、功能函数（获取当前时间、mac地址等）、网络状态、UI弹框、开启定位。。。</p><p>3）Appdelegate代码混乱。目前Appdelagate里的代码有：设置环境、bugly初始化、友盟初始化、融云初始化、百度地图初始化、蓝牙相关操作、日志组件功能、腾讯云初始化、广告组件。。。。</p><p>4）项目目录结构混乱</p><p>基础库、系统类扩展、UI组件、功能组件、三方库、上层业务代码、资源文件几乎都在同一级目录下</p><h2 id="Part2-组件化方案"><a href="#Part2-组件化方案" class="headerlink" title="Part2 组件化方案"></a>Part2 组件化方案</h2><p>iOS组件化方案基于Pod代码管理技术 + 组件协议解耦技术 + App路由解耦技术   + AppDeletegate瘦身技术 四个部分组成。其中组件代码会用cocopods私有库管理，与主工程分开维护。</p><p>为何不使用第三方框架：</p><p>网上开源框架各有各的问题，要么无法满足需求，要么学习成本高，要么实现方式不够简洁</p><p>a）BeeHive 阿里解耦框架  <a href="https://github.com/alibaba/BeeHive" target="_blank" rel="noopener">https://github.com/alibaba/BeeHive</a><br>优点：</p><ol><li>涵盖了几乎除runtime外所有组件化的技术</li><li>功能丰富，比如plist配置模块、异步加载等</li></ol><p>缺点：</p><ol><li>学习成本高，框架概念模糊，框架内一个模块包含多个服务，容易让人混淆</li><li>在系统事件上封装做了许多封装，其实比较多余，造成理解上的困难</li><li>一些我们用不到的功能，对我们来说是累赘</li></ol><p>b）CTMediator（runtime解耦策略）</p><p>问题：</p><ol><li>无法调用实例方法</li><li>无法支持调用多参函数，无法传入非id型变量</li><li>因为以上两个问题，用CTMediaor就没办法解第三方库耦合，最多用来解自己写的组件</li></ol><h3 id="一、Pod代码管理技术"><a href="#一、Pod代码管理技术" class="headerlink" title="一、Pod代码管理技术"></a>一、Pod代码管理技术</h3><p>组件代码用pod引入，使用pod既能管理三方库、也能管理子模块代码以及资源文件。</p><p>a）用pod引用工程代码</p><p>b）用pod引入资源</p><p>c）用pod管理子模块依赖</p><p>总结：采用Pod可方便的管理git子模块，只需学习配置规则无后续成本。Pod在配置好以后，在Pod install时会自动生成xcode子工程，Pod代码管理方案已被业界普遍采用。</p><h3 id="二、组件协议解耦技术-PHIServiceManager"><a href="#二、组件协议解耦技术-PHIServiceManager" class="headerlink" title="二、组件协议解耦技术 (PHIServiceManager)"></a>二、组件协议解耦技术 (PHIServiceManager)</h3><p>组件化的目的是模块解耦，解耦的目的是为了模块复用，所以各个模块间的耦合需要在组件化的过程中去掉。</p><p>a) 根据设计模式的“依赖倒置原则”，高层不依赖于低层的实现，依赖于抽象；具体实现依赖于抽象</p><p>b) 设计组件时，先根据组件的功能定义好组件对外的接口。并把接口封装成组件的协议</p><p>c）高层面向协议调用组件；组件内部依据协议实现组件。</p><p>总结：使用协议解耦是软件工程中常用到的手段，对于OC来讲，正好提供了协议功能。</p><h3 id="三、App路由解耦技术-（PHIRoute）"><a href="#三、App路由解耦技术-（PHIRoute）" class="headerlink" title="三、App路由解耦技术 （PHIRoute）"></a>三、App路由解耦技术 （PHIRoute）</h3><p>路由解耦的核心思想是消息分发，“把事情交给对应的人去做”。实现思路是把事件通过路由管理器分发到对应的组件，对应的组件执行完成后，通过路由管理器再带回结果。事件分发以URI为载体，带入事件名+参数 。 例如：做页面的跳转，事件发送到模块后，通过参数初始化好controller，再调用共用的navigation push。</p><p>a）路由管理器的实现</p><p>b）路由注册（收到事件后的处理方法）</p><p>c）路由事件发起</p><p>Q: 为何不用runtime做路由</p><p>A: runtime做路由，swift的模块就无法解耦。swift模块可用消息分发路由解耦。</p><p>总结：基于路由技术做解耦比组件协议解耦更加灵活，组件协议虽然解除了耦合，但还是需要依赖抽象的协议。某些时候还是略显麻烦，基于路由事件分发，路由事件发起者不需要引用接受者的模块，直接发起事件，如果接受者在管理器中有注册，则事件得到处理。</p><p>四、AppDelegate瘦身技术 （PHIEngine）<br>Appdelegate承载系统许多模块初始化 &amp; APP 状态切换后相应的工作，因此许多项目的Appdelegate非常庞大难以维护。AppDelegate瘦身技术的原理是把系统消息如didfinishLanuc通过“app管理器”分发出去，再由各个模块分别处理。</p><p>a）app管理器实现</p><p>b）模块注册</p><p>c）事件响应</p><p>总结：AppDelegate瘦身技术能有效解决Appdelegate代码杂乱的问题。</p><h3 id="四、Runtime解耦技术（PHIMediator）"><a href="#四、Runtime解耦技术（PHIMediator）" class="headerlink" title="四、Runtime解耦技术（PHIMediator）"></a>四、Runtime解耦技术（PHIMediator）</h3><p>对于第三方库带来的耦合，由于不方便注入代码，使用路由解耦会比较麻烦。<br>这种场景适用于Runtime解耦技术，通过Runtime的接口调用第三方库</p><p>总结：多种解构技术在项目中都会使用，按照具体场景选择解耦最适合的解耦方式</p><h2 id="Part3-实施步骤"><a href="#Part3-实施步骤" class="headerlink" title="Part3    实施步骤"></a>Part3    实施步骤</h2><ol><li>公共模块抽离git子模块，并用pod管理。包括共用组件、UI控件、公共方法等</li><li>引入PHIEngine，使appdelegate瘦身，同时抽离基础组件</li><li>引入serviceProtocol，用协议解耦组件</li><li>引入PHIRoute，做事件路由</li><li>引入Runtime 解耦技术</li><li>重新梳理代码目录结构</li><li>开发配置组件，把业务需要的配置抽到配置层</li><li>把组件化方案同步到其他业务线</li></ol><p>总结：重构完成后的代码结构会较为清晰，各个基础组件也可单独维护和使用，基础组件的更换不会影响到业务层的开发，代码复用性加强，各个业务线可用一套基础组件</p><h2 id="Part4-其他"><a href="#Part4-其他" class="headerlink" title="Part4    其他"></a>Part4    其他</h2><p>工程组件化的目的不仅是为了目前组件的复用，也是为以后新组件开发打好基础</p><p>a）debugger组件开发</p><ul><li>给测试和联调用户使用</li><li>查询日志</li><li>切换网络环境</li><li>…</li></ul><p>b）性能监听组件开发</p><ul><li>性能检测</li><li>网络检测</li><li>…</li></ul><p>参考资料：<br>podSpec语法 <a href="https://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="noopener">https://guides.cocoapods.org/syntax/podspec.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;组件化开发是一种软件架构思想，其目的是提高软件可维护性、代码复用性，有以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;组件独立于项目，与项目
      
    
    </summary>
    
    
      <category term="组件化" scheme="https://wangdachui.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
</feed>
